---
title: 操作系统
toc: true
date: 2018-09-30 15:02:58
tags: [操作系统]
categories: [计算机基础]
---

# 概述

## 基本特征

1. 并发

   **并发和并行的区别：**

   - 并发要求在一段时间内处理多件事物的能力，但不要求同时；

   - 并行要求同时处理多件事物的能力。

   - 单核CPU中，线程和进程用于支持并发。多核CPU可以支持并行。

2. 共享

   共享指操作系统中的资源可以被多个并发进程使用。

   共享方式：**同步、互斥**

3. 虚拟

   两种虚拟技术：**时分复用技术（多进程），空分复用技术（虚拟内存）**；

4. 异步

   指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。

## 基本功能

**进程管理、文件管理、内存管理、设备管理**

## 中断分类

1. 外中断

   由CPU执行指令以外的事件引起，如I/O完成中断、时钟中断、控制台中断等。

2. 异常

   由CPU执行指令的内部事件引起，如非法操作码、地址越界、溢出等。

3. 陷入

   在用户程序中使用系统调用。

# 进程管理

## 进程&线程

|                   进程                   |          线程          |
| :--------------------------------------: | :--------------------: |
|            资源分配的最小单位            |     调度的最小单位     |
| 系统开销大（创建/删除是要分配/回收资源） |       系统开销小       |
|             通信需要借助IPC              | 直接读写同一进程的内存 |
|      一个进程的崩溃不会影响其他进程      |  一个线程的崩溃会导致  |
|      一个进程可以包含一个或多个线程      |                        |

## 进程状态

1. 就绪（等待被调度）
2. 运行
3. 阻塞（等待资源）

**进程状态间的转换条件：**

* 就绪 ➡ 执行

  进程调度程序为处于就绪状态的进程分配了处理机后，该进程转位执行状态。

* 执行 ➡ 就绪

  处于执行状态的进程，时间片结束后，不得不释放处理机，转为就绪状态。

* 执行 ➡ 阻塞

  正在执行的进程因等待某个资源或事件发生而无法继续执行，则变成阻塞状态。

- 阻塞 ➡ 就绪

  处于阻塞状态的进程，等待的资源得到满足或者等待的事件已经发生，则进入就绪状态。

## 进程调度算法

**不同系统调度算法不同，以下针对三种系统进行讨论：**

1. 批处理系统先来先服务（FCFS）

   * 先来先服务

     有利于长作业，不利于短作业，短作业需一直等长作业完成才能进行。

   * 短作业优先（SJF）

     长作业可能会一直处于等待状态。

   * 最短剩余时间优先（SRTN）

     按估计的剩余时间最短的顺序进行调度。

2. 交互式系统

   - 时间片轮转（RR）

     按先来先服务原则将所有就绪进程放入队列，每次调度时，把时间分给队首进程，该进程可以执行一个时间片，时间用尽后，由计时器发出时钟中断，调度程序便停止该进程的执行，并将他放到队列队尾。

     **时间片轮转算法：a. 时间片太小，进程间需要频繁切换，且每次切换都要保存进程信息并载入新进程信息，开销大； b. 时间片太大，实时性差。**

   - 优先级调度

     为进程分配一个优先级，按照优先级进行调度。为避免低优先级的进程永远处于等待状态，随时间增加而增加等待进程的优先级。

   - 多级反馈队列（抢占式调度算法）

     a. 设计多个就绪队列，每个队列优先级不同，优先级越高，该队列中进程的时间片越小； b. 当一个新进程进入内存后，放入优先级最高的队列1的队尾，等待调度，如果在该时间片内为执行完，则转入队列2的队尾； c. 只有当上一个队列为空时，才会调度下一个优先级的队列中的进程。

     **如果处理机正在执行第i级队列中的某进程时，又有新进程进入优先级较高的队列（第 1 ~ (i-1)中的任何一个队列），则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第i级队列的末尾，把处理机分配给新到的更高优先级的进程。**

3. 实时系统

   硬实时：必须满足绝对的截止时间

   软实时：可以容忍一定的超时

## 进程同步

1. 临界区

   每个进程在进入临界区之前，需要先进行检查。保证某一时刻只能有一个进程能访问数据。在一个进程进入临界区之后，其他进程要想要访问将会被挂起。

2. 同步&互斥

   同步：多个进程按一定顺序执行

   互斥：多个进程在同一时刻只有一个进程能进入临界区

3. 信号量（down/up操作，即p/v操作）

   down：如果信号量 >1，执行 -1 操作：如果信号量 = 0，则进程被阻塞。

   up：对信号量执行 +1 操作，唤醒阻塞的进程让其完成down操作。

   **down/up要被设计成原语，不可分割；如果信号量最大值为1，则等同于互斥量，为0表示临界区已经加锁，为1表示临界区已经解锁。**

4. 管程


## 进程通信

1. 管道

   半双工通信；父子进程中使用；

2. FIFO

   命名管道，去除了管道只能在父子进程中使用的限制。

3. 消息队列

   - 独立于读写进程存在，避免了FIFO中同步管道的打开和关闭时可能产生的困难；
   - 避免FIFO的同步阻塞问题，不需要进程自己提供同步方法；
   - 读进程可以根据消息类型有选择的接受消息，而不像FIFO那样只能默认的接收

4. 信号量

5. 共享内存

   - 允许多个进程共享一个给定的存储区。最快的IPC。
   - 需要使用信号量来同步对共享内存的访问。
   - 多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。

6. 套接字

   可用于不同机器之间进行通信。

**注意：**

	**进程通信：进程间传输信息。**

	**进程同步：控制多个进程按一定顺序执行。**

	**进程通信是一种手段，进程同步是目的。**

# 死锁

## 必要条件

1. 资源互斥
2. 环路等待
3. 不可抢占
4. 占有和等待

## 处理方法

1. 鸵鸟策略（死锁发生时）

   死锁概率发生极低的情况下采用，鸵鸟策略即在死锁发生时不采取任何措施。

2. 死锁检测与死锁恢复（死锁发生时）

   在死锁发生时进行恢复。

   检测方法：

    - **每种类型一个资源的死锁检测**：检测有向图，从一个节点出发，深度遍历，检测是否存在回路。
    - **每个类型多个资源的死锁检测**：E向量：资源总量，A向量：资源剩余量，C矩阵：每个进程所拥有的资				源数量，每一行都代表一个进程拥有的资源的数量，R矩阵：每个进程请求的资源数量。**步骤**：1⃣初始化进程均未被标记；2⃣寻找一个没有被标记的进程，对应的R小于A，表示该进程可以执行，标记该进程，并把该进程对应的C加到A上；3⃣如果不存在进程满足1⃣中的条件，算法结束，所有没有被标记的进程都是死锁进程。

   恢复方法：抢占恢复、回滚恢复、杀死进程恢复

3. 死锁预防（程序运行前）

   - 破坏互斥条件
   - 破坏占有和等待条件（一个进程必须一次性请求到全部资源）
   - 破坏不可抢占条件
   - 破坏环路等待条件（顺序分配）

4. 死锁避免（程序运行时，死锁发生前）

   类似死锁检测，要求程序是安全状态，即不能发生死锁，可以用死锁检测的方法去判断是否会发生死锁，如果会，则拒绝请求。

# 内存管理

 ## 页面置换算法

1. 最佳（理论上的算法）

   将来最长时间内不再被访问的页面调出。

2. 最近最久未使用（LRU）

   链表实现，某个页一旦被使用，就放到表头，这样就能保证表尾的页一定是最近最久未使用的。

3. 最近未使用（NRU）

4. 先进先出（FIFO）

5. 第二次机会算法

   FIFO算法的改进，结合NRU算法，避免将经常使用的页面置换回去。页面被访问时，R置为1，需要替换时，检查最老页面的R，如果R为0，直接替换，否则，R置0，并放到链表尾部，继续检查链表头。

6. 时钟

   第二次机会算法的改进，使用环形链表，移动头指针。

## 分段

分页算法遇到动态增长问题会导致覆盖问题。因此可以采用分段算法，一个段构成一个独立的地址空间，没个段长度可以不同，并且可以动态增长。

## 段页式

程序的地址空间划分成多个拥有独立地址的段，每个段再划分成多个大小相等的页，即拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。

## 分页与分段的比较

1. 对程序员的透明性：分页透明，分段需要程序员显示划分每个段
2. 地址空间维度：分页是一维地址空间，分段是二维
3. 大小是否可变：分页不可变，分段可动态改变
4. 出现的原因：分页用于实现虚拟内存，获得更大的地址空间；分段是为了使程序和数据可以被划分为逻辑上的独立的地址空间并且有助于共享和保护。

